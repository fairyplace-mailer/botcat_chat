**Техническое задание**

BOTCAT™ CONSULTANT v1.0

**0. ВВОДНАЯ ЧАСТЬ**

**0.1. Цель документа**

Цель --- зафиксировать архитектуру системы BotCat™ Consultant v1.0:

**0.2. Задачи и этапы реализации**

Этап 1

\* веб-чат для клиентов,

\* интеграция с OpenAI,

\* сохранение и обработка стенограмм,

\* генерация HTML и PDF,

\* автоматическая отправка писем,

\* работа с файлами и изображениями,

\* поддержка PWA,

\* статистика,

\* возможность обучения модели,

Этап 2

\* интеграция с WhatsApp (AI бот),

\* интеграция с Instagram (AI бот),

\* интеграция с Telegram (AI бот),

\* интеграция с Messanger (AI бот),

\* интеграция с Viber (AI бот),

\* личный кабинет пользователей.

Этап 3

\* возможность развития в мобильные приложения.

\-\--

**1. ОБЩАЯ КОНЦЕПЦИЯ**

**1.1. BotCat™ Consultant v1.0**

Это AI-сервис, который:

\* общается с клиентами на сайте \`fairyplace.net/chat\`,

\* помогает собрать вводные данные для будущих дизайн-проектов
FairyPlace™,

\* автоматически формирует стенограмму диалога,

\* генерирует HTML и PDF-версии стенограммы,

\* отправляет материалы дизайнерам FairyPlace™ и клиенту (по его
желанию),

\* хранит и логирует диалоги,

\* поддерживает PWA,

\* собирает статистику,

\* обеспечивает возможность обучения модели на реальных диалогах.

В проекте используется собственный AI-ассистент (BotCat) через OpenAI
API.

**1.2. Общие требования**

Сервис должен быть:

\* стабильным,

\* масштабируемым,

\* быстрым,

\* расширяемым для мобильных приложений и новых функций.

Все компоненты --- изолированные:

\* UI --- в браузере клиента,

\* API --- в backend на Vercel,

\* AI --- в OpenAI,

\* хранилище файлов --- Vercel Blob,

\* хранилище PDF --- Google Drive,

\* почта --- Resend,

\* база данных --- Vercel Postgres.

\-\--

**2. ПОЛЬЗОВАТЕЛЬСКИЕ СЦЕНАРИИ**

**2.1. Основной сценарий: клиент** → **диалог** → **письмо дизайнерам**

1\. Клиент открывает \`https://fairyplace.net/chat\`.

2\. Начинает общение с BotCat.

3\. Загружает свои изображения или документы.

4\. BotCat генерирует свои изображения (через OpenAI).

5\. Возможно общение в голосовом чате (через OpenAI).

6\. По окончании диалога BotCat формирует полный пакет стенограммы.

7\. Backend принимает стенограмму, генерирует:

\* HTML \`\<chatName\>.html\`,

\* PDF \`\<chatName\>.pdf\`.

8\. Backend автоматически отправляет письмо на
\`fairyplace.tm@gmail.com\`.

9\. Диалог сохраняется в базе данных .

**2.2. Отправка материалов клиенту**

Если клиент указал email:

\* ему отправляется письмо со стенограммой.

**2.3. Регистрация / Личный кабинет**

Будет реализовано на втором этапе:

\* регистрация по email / OAuth,

\* просмотр своих прошлых диалогов,

\* скачивание HTML/PDF,

\* управление настройками.

\-\--

**3. АРХИТЕКТУРА СИСТЕМЫ**

**3.1. Высокоуровневая схема**

\`\`\`

Пользователь → Browser UI → Backend (Next.js API) → OpenAI (BotCat)

↘

Vercel Blob

Google Drive

Resend Email

Postgres DB

\`\`\`

Компоненты изолированы, API --- единый.

**3.2. Компоненты**

3.2.1. **Frontend UI (Next.js / React)**

• Web‑чат на https://fairyplace.net\
• Пузырьки сообщений\
• Загрузка файлов напрямую в Blob\
• Предпросмотр изображений\
• Отображение изображений, сгенерированных ботом\
• PWA (manifest, service worker, standalone)

3.2.2. **Backend API (Next.js)**

**Эндпоинты**:\
- \`/api/chat\` --- прокси к OpenAI\
- \`/api/bot/webhook\` --- принимает финальный пакет стенограммы\
- \`/conversations/\[chatName\]\` --- SSR HTML\
- \`/api/conversations/\[chatName\]/pdf\` --- PDF

**Backend API specification**

3.2.2.1. **POST /api/chat**

Назначение: основной endpoint для общения веб-чата с BotCat через OpenAI
(stream).

Запрос

Метод: POST

Заголовки:

Content-Type: application/json

Тело (пример):

{

\"chatName\": null,

\"message\": \"Текст сообщения пользователя\...\",

\"attachments\": \[

{

\"blobKey\": \"uploads/\...\",

\"fileName\": \"plan.pdf\",

\"mimeType\": \"application/pdf\",

\"fileSizeBytes\": 123456

}

\],

\"client\": {

\"sessionId\": \"c7f3d5c0-6f0c-4c5a-9f3b-2f3e\...\",

\"userAgent\": \"Mozilla/5.0 \...\",

\"ipHash\": \"sha256:\...\"

}

}

Поля:

- chatName --- string \| null:

  - null для первого сообщения в сессии (backend/BotCat назначают новый
    chatName);

  - строка --- для продолжения существующей беседы.

- message --- string, обязательно, текст последнего сообщения
  пользователя.

- attachments\[\] --- список файлов, загруженных через Blob:

  - blobKey, fileName, mimeType, fileSizeBytes.

- client --- метаданные клиента:

  - sessionId --- внутренний ID сессии;

  - userAgent, ipHash --- для логирования и статистики.

Ответ

- Код: 200 OK

- Тип: text/event-stream (SSE) или stream-chunked (в зависимости от
  реализации).

- События:

  - события с токенами модели;

  - финальное событие с метаданными, напр.:

{

\"type\": \"final\",

\"chatName\": \"FP_2025-01-01_12-00-01_abc123\",

\"messageId\": \"FP_2025-01-01_12-00-01_abc123\_\_b_001\"

}

Ошибки:

- 400 --- некорректный запрос;

- 500 --- ошибка сервера / OpenAI.

3.2.2.2. **POST /api/bot/webhook**

Назначение: прием финального пакета стенограммы от BotCat (итоговый
JSON).

Запрос

Метод: POST

Заголовки:

Content-Type: application/json

(опционально) X-Botcat-Secret: \<секрет\> --- защита от внешних вызовов.

Тело: полный JSON по «ПАТЧ 2» (BotCat итоговый JSON).

Ответ

Успех:

{

\"ok\": true

}

- Код: 200 OK.

Ошибка валидации:

{

\"ok\": false,

\"error\": \"ValidationError: \...\"

}

- Код: 400 Bad Request.

Внутренняя ошибка:

{

\"ok\": false,

\"error\": \"InternalError: \...\"

}

- Код: 500 Internal Server Error.

Поведение backend:

- валидирует JSON по схеме;

- создает/обновляет Conversation, Message, Attachment;

- генерирует HTML и PDF;

- сохраняет PDF в Google Drive;

- отправляет письма через Resend;

- пишет записи в webhook_logs, email_logs, daily_stats.

3.2.2.3. **GET /conversations/\[chatName\]**

Назначение: SSR HTML-страница с результатами диалога.

Запрос

- Метод: GET

- Путь: /conversations/:chatName

- Параметры:

  - chatName --- string, обязателен.

Ответ

- Код: 200 OK

- Тип: text/html

- Содержимое: HTML-страница с:

  - кратким резюме (preamble_md);

  - стенограммой (на основе messages + translatedMessages);

  - блоками вложений;

  - ссылками на PDF и др. (если предусмотрено).

Ошибки:

- 404 Not Found --- если chatName не найден;

- 410 Gone --- если стенограмма/файлы удалены по TTL и политикам.

3.2.2.4. **GET /api/conversations/\[chatName\]/pdf**

Назначение: выдача PDF-версии стенограммы.

Запрос

- Метод: GET

- Путь: /api/conversations/:chatName/pdf

- Параметры:

  - chatName --- string, обязателен.

Ответ

Успех:

Код: 200 OK

Заголовки:

Content-Type: application/pdf

Content-Disposition: attachment; filename=\"\<chatName\>.pdf\"

Тело: бинарный PDF.

Ошибки:

- 404 Not Found --- если pdf не найден;

- 410 Gone --- если pdf удален по TTL/cleanup;

<!-- -->

- 500 --- внутренняя ошибка.\
  \
  **Функционал backend**:\
  - валидация данных\
  - запись в БД\
  - генерация HTML и PDF\
  - загрузка PDF в Google Drive\
  - отправка писем через Resend

3.2.3. **JSON-контракт BotCat** → **backend**

**Формат итогового JSON (BotCat** → **/api/bot/webhook)**

BotCat по завершении диалога (по команде от backend-оркестратора)
формирует и отправляет на /api/bot/webhook JSON в следующем формате:

{

\"schemaVersion\": \"1.0\",

\"chatName\": \"FP_2025-01-01_12-00-01_abc123\",

\"languageOriginal\": \"ru\",

\"messages\": \[

{

\"messageId\": \"FP_2025-01-01_12-00-01_abc123\_\_u_001\",

\"role\": \"User\",

\"contentOriginal_md\": \"Текст сообщения пользователя с \[voice\] при
необходимости\...\",

\"hasAttachments\": true,

\"hasLinks\": true,

\"isVoice\": true,

\"createdAt\": \"2025-01-01T12:00:05Z\"

}

// \...

\],

\"translatedMessages\": {

\"FP_2025-01-01_12-00-01_abc123\_\_u_001\": {

\"contentTranslated_md\": \"Перевод на русский (или оригинал, если язык
уже ru)\...\",

\"language\": \"ru\"

}

// \...

},

\"attachments\": \[

{

\"attachmentId\": \"att_001\",

\"messageId\": \"FP_2025-01-01_12-00-01_abc123\_\_u_001\",

\"kind\": \"user_upload\",

\"fileName\": \"plan.pdf\",

\"mimeType\": \"application/pdf\",

\"fileSizeBytes\": 123456,

\"pageCount\": 4,

\"originalUrl\": \"https://example.com/original/plan.pdf\",

\"blobUrlOriginal\": \"https://blob.vercel.store/\...\",

\"blobUrlPreview\": \"https://blob.vercel.store/preview/\...\"

}

// \...

\],

\"preamble_md\": \"Краткий brief / резюме диалога в markdown\...\",

\"footerInternal_md\": \"\",

\"footerClient_md\": \"\",

\"sendToInternal\": true

}

3.2.3.1. Общие поля

schemaVersion --- string, опционально, версия схемы (по умолчанию
\"1.0\").

chatName --- string, обязателен, глобально уникальное имя диалога (см.
правила формирования).

languageOriginal --- string, обязателен, двухбуквенный код ISO 639-1
исходного языка диалога (например, \"ru\", \"en\").

sendToInternal --- boolean, обязателен:

true --- диалог нужно отправить внутренней команде
(fairyplace.tm@gmail.com и др.).

false --- только клиент (если указал email), без внутреннего письма.

3.2.3.2. Массив messages

messages --- **полная стенограмма** без сокращений, в хронологическом
порядке.

Элемент:

- messageId --- string, обязателен:

  - формат: \<chatName\>\_\_u_XXX или \<chatName\>\_\_b_XXX;

  - XXX --- трехзначный номер с ведущими нулями: 001, 002, \...

- role --- string, обязателен:

  - \"User\" --- реплика пользователя;

  - \"BotCat\" --- реплика бота.

- contentOriginal_md --- string, обязателен:

  - исходный текст сообщения в markdown, со всеми тегами (\[voice\],
    ссылки, форматирование и т.п.).

- hasAttachments --- boolean, обязателен:

  - true, если в сообщении есть файл/файлы.

- hasLinks --- boolean, обязателен:

  - true, если в сообщении есть одна или несколько ссылок (URL).

- isVoice --- boolean, обязателен:

  - true, если сообщение было получено через voice-режим (и содержит
    \[voice\]).

- createdAt --- string, обязателен, время сообщения в формате ISO 8601
  (UTC).

3.2.3.3. Объект translatedMessages

translatedMessages --- словарь (dict) вида messageId → объект перевода.

Ключ:

- messageId --- тот же, что в messages\[\].

Значение:

- contentTranslated_md --- string, обязателен:

  - если исходный язык ≠ \"ru\" --- полный перевод на русский с
    сохранением структуры и форматирования;

  - если язык = \"ru\" --- оригинальный текст, скопированный из
    contentOriginal_md.

- language --- string, обязателен, код языка содержимого
  contentTranslated_md (обычно \"ru\").

Правила:

- всегда заполняется для всех messageId из messages\[\];

- имена собственные, числа, код, URL не переводятся.

3.2.3.4. Массив attachments

attachments содержит весь список файлов и иллюстраций, связанных с
диалогом.

Элемент:

attachmentId --- string, обязателен, уникальный ID вложения в рамках
JSON.

messageId --- string, обязателен, ссылка на messages.messageId, откуда
это вложение.

kind --- string, обязателен:

\"user_upload\" --- файл, присланный пользователем;

\"bot_generated\" --- файл/изображение, сгенерированное ботом;

\"external_url\" --- внешняя иллюстрация / ссылка (URL).

fileName --- string, nullable (может быть пустым для чисто внешних URL).

mimeType --- string, nullable (MIME-тип, если известен).

fileSizeBytes --- integer, nullable (размер в байтах, если есть).

pageCount --- integer, nullable (для документов, если есть).

originalUrl --- string, nullable (оригинальная ссылка, если файл пришел
как URL).

blobUrlOriginal --- string, nullable (прямая Blob-ссылка на оригинал).

blobUrlPreview --- string, nullable (Blob-ссылка на превью / thumbnail).

3.2.3.5. Блоки preamble_md, footerInternal_md, footerClient_md

- preamble_md --- string, обязателен:

  - краткий brief / обзор диалога в markdown;

  - используется в HTML-странице и в письмах.

- footerInternal_md --- string, обязателен, может быть \"\":

  - текст (markdown) только для внутреннего письма (дизайнерам).

- footerClient_md --- string, обязателен, может быть \"\":

  - текст (markdown) только для письма клиенту.

3.2.4. **ERD и модель данных**

Основные сущности:\
User, Conversation, Message, Attachment, EmailLog, WebhookLog,
DailyStats, CronLock, CleanupLog.

Все PK --- uuid, если не указано иначе. Все timestamps --- timestamptz
(UTC).

**Таблица users**

Назначение: хранение базовой информации о пользователях (в т.ч.
анонимных с email).

Поля:

- id --- PK, uuid.

- email --- text, nullable, unique (email клиента, если указан).

- created_at --- timestamptz, not null, default now().

- updated_at --- timestamptz, not null, default now().

Индексы:

- unique (email).

Таблица conversations

Назначение: одна запись на один диалог (chatName).

Поля:

- id --- PK, uuid.

- chat_name --- text, not null, unique (тот самый chatName из BotCat).

- user_id --- uuid, FK → users.id, nullable, ON DELETE SET NULL.

- status --- text, not null, enum: \'active\' \| \'closed\'.

- language_original --- text, not null (ISO 639-1, напр. \"ru\",
  \"en\").

- send_to_internal --- boolean, not null, default true (из итогового
  JSON).

- started_at --- timestamptz, not null (первая фраза пользователя).

- finished_at --- timestamptz, nullable.

- last_activity_at --- timestamptz, not null.

- message_count --- integer, not null, default 0.

- meta --- jsonb, nullable (userAgent, ip_hash, referrer, канал:
  \"web\", и т.п.).

Индексы:

- unique (chat_name).

- (user_id, started_at).

- (status, last_activity_at).

Связи:

- Conversation 1-ко-многим Message.

- Conversation 1-ко-многим Attachment.

- Conversation 1-ко-многим EmailLog.

- Conversation 1-ко-многим WebhookLog.

**Таблица messages**

Назначение: отдельные реплики пользователя и BotCat.

Поля:

- id --- PK, uuid.

- conversation_id --- uuid, not null, FK → conversations.id, ON DELETE
  CASCADE.

- message_id --- text, not null, unique (формат \<chatName\>\_\_u_XXX
  или \<chatName\>\_\_b_XXX).

- role --- text, not null, enum: \'User\' \| \'BotCat\' (ровно как в
  ТЗ).

- content_original_md --- text, not null (полный текст с форматированием
  и тегами \[voice\], ссылками и т.п.).

- content_translated_md --- text, nullable (соответствующая запись из
  translatedMessages, если есть).

- has_attachments --- boolean, not null, default false.

- has_links --- boolean, not null, default false.

- is_voice --- boolean, not null, default false (на основе \[voice\]).

- created_at --- timestamptz, not null.

- sequence --- integer, not null (порядковый номер в диалоге).

Индексы:

- unique (message_id).

- (conversation_id, sequence).

- (conversation_id, created_at).

Связи:

- Message 1-ко-многим Attachment (по message_id).

**Таблица attachments**

Назначение: все файлы и внешние ссылки, связанные с диалогом.

Поля:

- id --- PK, uuid.

- conversation_id --- uuid, not null, FK → conversations.id, ON DELETE
  CASCADE.

- message_id --- text, not null, FK (логическая) → messages.message_id.

- kind --- text, not null, enum: \'user_upload\' \| \'bot_generated\' \|
  \'external_url\'.

- file_name --- text, nullable.

- mime_type --- text, nullable.

- file_size_bytes --- integer, nullable.

- page_count --- integer, nullable (для PDF/документов).

- blob_key_original --- text, nullable (ключ в Vercel Blob).

- blob_url_original --- text, nullable (прямая ссылка на оригинал).

- blob_url_preview --- text, nullable (превью/thumbnail).

- external_url --- text, nullable (если файл --- внешняя ссылка, а не
  Blob).

- created_at --- timestamptz, not null, default now().

- expires_at --- timestamptz, not null (TTL +30 дней).

- deleted_at --- timestamptz, nullable (после cron-очистки или мягкого
  удаления).

Индексы:

- (conversation_id).

- (message_id).

- (expires_at).

- (kind, created_at).

**Таблица email_logs**

Назначение: лог всех отправленных писем (дизайнерам и клиенту).

Поля:

- id --- PK, uuid.

- conversation_id --- uuid, not null, FK → conversations.id, ON DELETE
  CASCADE.

- recipient_email --- text, not null.

- subject --- text, not null.

- status --- text, not null, enum: \'queued\' \| \'sent\' \| \'failed\'.

- provider_message_id --- text, nullable (ID письма в Resend).

- error_message --- text, nullable.

- created_at --- timestamptz, not null, default now().

Индексы:

- (conversation_id, created_at).

- (status, created_at).

**Таблица webhook_logs**

Назначение: аудит вызовов /api/bot/webhook (итоговый JSON).

Поля:

- id --- PK, uuid.

- conversation_id --- uuid, nullable, FK → conversations.id, ON DELETE
  SET NULL (на случай ошибки до создания conversation).

- payload --- jsonb, not null (сырой финальный JSON от BotCat).

- status_code --- integer, not null (ответ backend → BotCat).

- error_message --- text, nullable.

- created_at --- timestamptz, not null, default now().

Индексы:

- (conversation_id, created_at).

**Таблица daily_stats**

Назначение: агрегированная статистика по дате.

Поля:

- date --- date, not null.

- channel --- text, not null, default \'web\'.

- total_conversations --- integer, not null, default 0.

- total_messages --- integer, not null, default 0.

- total_attachments --- integer, not null, default 0.

- total_emails_sent --- integer, not null, default 0.

- total_tokens_prompt --- bigint, not null, default 0.

- total_tokens_completion --- bigint, not null, default 0.

- total_tokens_total --- bigint, not null, default 0.

- total_uploaded_bytes --- bigint, not null, default 0.

- total_blob_files --- integer, not null, default 0.

- created_at --- timestamptz, not null, default now().

PK:

- primary key (date, channel).

Индексы:

- (date).

Таблица cron_locks

Назначение: защита от параллельного запуска cron-задач (очистка,
агрегации и т.п.).

Поля:

- name --- text, PK (уникальное имя задачи: \'cleanup_blob\',
  \'aggregate_stats_daily\' и т.п.).

- locked_at --- timestamptz, not null.

- locked_until --- timestamptz, not null.

- meta --- jsonb, nullable (диагностика, host, попытки и т.д.).

**Таблица cleanup_logs**

Назначение: лог запусков задач очистки (TTL файлов, soft delete и т.п.).

Поля:

- id --- PK, uuid.

- task_name --- text, not null (напр. \'cleanup_expired_attachments\').

- run_started_at --- timestamptz, not null.

- run_finished_at --- timestamptz, nullable.

- deleted_attachments_count --- integer, not null, default 0.

- deleted_conversations_count --- integer, not null, default 0.

- errors --- jsonb, nullable (список ошибок / проблемных id).

Индексы:

- (task_name, run_started_at).

3.2.5. **BotCat (OpenAI Assistant)**

• Назначение chatName после первой фразы;\
• messageId формата \`\<chatName\>\_\_u_XXX\` и
\`\<chatName\>\_\_b_XXX\`;\
• role (BotCat / User) перед текстом сообщения;

• Перевод всех сообщений если язык ≠ ru

(если язык = ru, копировать в translatedMessage по messageId);\
• Голос → текст, добавление \`\[voice\]\` перед role, по messageId;\
• Формирование полной стенограммы по messageId;\
• Возврат финального JSON в backend.

3.2.6. Dynamic Model Selection

Для обеспечения оптимального баланса качества, скорости и стоимости,
backend-оркестратор использует динамический выбор моделей OpenAI на
каждом шаге диалога.\
BotCat НЕ принимает участия в выборе моделей и не знает, какая
конкретная модель используется в данный момент. Логика выбора полностью
находится на стороне backend.

Tech_Spec_v1

3.2.6.1. Общие правила

- Перед каждым запросом к OpenAI backend выбирает модель на основе:

  - типа задачи (обычный ответ, сложное рассуждение, финализация JSON,
    генерация изображений, embeddings);

  - длины и сложности контекста;

  - допустимой стоимости и задержки.

- Формат сообщений, структура контекста, JSON-контракт и правила
  поведения BotCat остаются одинаковыми при любой модели.

- Выбор модели никак не отражается в ответах BotCat и не должен быть
  видим пользователю.

3.2.6.2. Используемые модели и env-переменные

Backend использует следующие модели (значения по умолчанию задаются в
env.ts):

- Основной чат:

  - OPENAI_MODEL_CHAT → по умолчанию gpt-4.1-mini.

- Усиленный чат:

  - OPENAI_MODEL_CHAT_STRONG → по умолчанию gpt-4.1.

- Reasoning:

  - OPENAI_MODEL_REASONING → по умолчанию o3-mini.

- Генерация изображений (основная):

  - OPENAI_MODEL_IMAGE → по умолчанию gpt-image-1-mini.

- Генерация изображений (премиум):

  - OPENAI_MODEL_IMAGE_HIGH → по умолчанию gpt-image-1.

- Embeddings:

  - OPENAI_MODEL_EMBEDDING → по умолчанию text-embedding-3-large.

Backend имеет право добавлять новые модели OpenAI при условии сохранения
совместимости с архитектурой и контрактами.

3.2.6.3. Правила выбора модели

3.2.6.3.1. Основной режим (default) --- OPENAI_MODEL_CHAT

Используется по умолчанию для:

всех стандартных сообщений пользователя;

диалогового консультирования по дизайну, текстилю, surface design и POD;

сбора вводных данных для брифа и заказа;

служебных сообщений BotCat и простых аналитических ответов.
BotCat_Key_Skills

3.2.6.3.2. Режим "усиленной экспертизы" --- OPENAI_MODEL_CHAT_STRONG

Оркестратор может переключиться на усиленную модель, если:

приходит длинное и сложное ТЗ (много абзацев, много условий и
ограничений);

требуется глубокий анализ интерьера/коллекции/бренда с множеством связок
и trade-off;

нужно синтезировать сложный концепт (мудборд, серия принтов, сценарий
коллекции) с большим количеством входных данных;

текущий ответ критичен по качеству (например, финальная рекомендация,
которую увидит клиент без доработки дизайнера).

3.2.6.3.3. [Режим "]{dir="rtl"}reasoning" --- OPENAI_MODEL_REASONING

Используется точечно, только когда задача требует:

строгой многошаговой логики (пошаговое сравнение сложных вариантов,
формальные выводы);

построения структурированных артефактов (сложные таблицы сравнений,
сценарные деревья, формальные чек-листы);

анализа больших массивов текста с жёсткими логическими зависимостями.

Оркестратор отвечает за минимизацию использования reasoning-модели из-за
её стоимости.

3.2.6.3.4. Режим генерации изображений --- OPENAI_MODEL_IMAGE /
OPENAI_MODEL_IMAGE_HIGH

- OPENAI_MODEL_IMAGE (mini) используется по умолчанию:

  - для быстрых эскизов, концептов и внутренних превью;

  - для технических иллюстраций (схемы, простые mockup-идеи).

- OPENAI_MODEL_IMAGE_HIGH включается, когда:

  - нужен максимально качественный визуал для клиента (мудборд, ключевые
    превью коллекции, презентационные материалы);

  - изображение потенциально пойдёт напрямую в клиентскую коммуникацию
    без существенной доработки. BotCat_Key_Skills

3.2.6.3.5. Embeddings --- OPENAI_MODEL_EMBEDDING

Используется вне online-диалога:

для построения поискового индекса по диалогам и материалам;

для RAG / аналитики / подготовки датасетов.

Online-логика BotCat и формат JSON не зависят от конкретной
embedding-модели.

3.2.6.4. Финализация JSON

Для формирования итогового JSON (финальная стенограмма и пакет для
/api/bot/webhook) backend использует:

**по умолчанию** OPENAI_MODEL_CHAT (стабильная, дешёвая и хорошо
следующая инструкциям модель),

при необходимости может временно переключиться на
OPENAI_MODEL_REASONING, если финализация требует сложной структурной
переработки данных.

Независимо от выбранной модели:

структура JSON, имена полей и все обязательные блоки **строго
фиксированы**;

backend всегда валидирует JSON перед сохранением. Tech_Spec_v1

3.2.6.5. Ответственность оркестратора

Оркестратор:

инициализирует выбор модели перед каждым запросом;

отслеживает тип задачи и сложность контекста;

управляет стоимостью и задержками;

гарантирует стабильность и предсказуемость диалога;

не нарушает контрактов BotCat и backend (все форматы и правила остаются
неизменными).

BotCat:

не знает, какие модели используются;

не запрашивает смену модели;

всегда следует своему system prompt и спецификациям JSON, независимо от
выбранной модели.

3.2.7. **Vercel Blob**

\* хранение всех файлов

(на этапе 1 учитывать ограничения Vercel Hobby).

3.2.8. **Google Drive**

\* хранение PDF стенограмм.

3.2.9. **Postgres DB**

\* хранение всей структуры диалога.

**Модели**:\
- Conversation\
- Message\
- Attachment\
- User (выполняется на этапе 2)

3.2.9. **Resend**

\* E-mail отправка. MAIL\_\_FROM: mailer@mail.fairyplace.net

\-\--

**4. FRONTEND UI**

**4.1. Адрес**

Чат доступен только по адресу:

\`\`\`https://fairyplace.net/chat\`\`\`

и как приложение (PWA).

**4.2. UI как чат-мессенджер**

Требования:

\* вид как WhatsApp:

\* пузырьки,

\* аватарки,

\* скроллинг,

\* предпросмотр картинок,

\* кнопка \`+\` (загрузить файл),

\* статус "печатает...".

**4.3. Загрузка файлов (USER** → **UI** → **BLOB)**

1\. Пользователь выбирает файл.

2\. UI напрямую загружает его в Blob.

3\. UI получает \`blobUrl\`.

4\. UI отправляет BotCat сообщение с \`blobUrl\`.

!! Файлы НЕ проходят через OpenAI !!

**4.4. Обработка изображений бота**

4.4.1. BotCat возвращает base64 изображения.

4.4.2. UI:

\* декодирует base64,

\* конвертирует в файл (PNG),

\* загружает файл в Blob,

\* получает \`blobUrl\`,

\* отображает его пользователю,

\* включает \`blobUrl\` в следующее сообщение боту или backend.

**4.5. PWA**

UI должен:

\* иметь \`manifest.json\`,

\* иметь service worker,

\* поддерживать "Install app",

\* работать в \`standalone\` режиме,

\* иметь иконки 192/512 px.

\-\--

**5. BOTCAT (OpenAI Assistant)**

**5.1. BotCat определяет:**

\* язык диалога,

\* \`chatName\` после первой реплики,

\* \`messageId\` для каждого сообщения.

**5.2. Перевод**

\* Если язык ≠ RU → каждое сообщение переводится,

\* Если язык = RU → перевод = оригинал.

**5.3. Голос**

STT → текст → добавление префикса \`\[voice\]\`.

**5.4. Стенограмма**

BotCat формирует:

\* все сообщения,

\* все вложения,

\* переводы,

\* brief,

\* итоговый JSON (см. далее)

Требования:\
• Полная и точная, без сокращений, пересказов, домыслов\
• Роли User/BotCat\
• Теги \`\[voice\]\`

**5.5. Финализация**

BotCat **одним** запросом отдаёт всё на backend.

\-\--

**6. BACKEND**

**6.1. Эндпоинты**

6.1.1. **\`/api/chat\`**

Прокси к OpenAI (для UI).

6.1.2. **\`/api/bot/webhook\`**

Главный эндпоинт.

**Принимает**:

\* messages\[\],

\* attachments\[\],

\* translatedMessages,

\* chatName,

\* preamble_md,

\* userEmails\[\].

6.1.3. **\`/conversations/\[chatName\]\`**

HTML-просмотр.

6.1.4. **\`/api/conversations/\[chatName\]/pdf\`**

Доступ к PDF.

\-\--

**7. ХРАНЕНИЕ ДАННЫХ (BD)**

Prisma / Postgres:

\* Conversation,

\* Message,

\* Attachment,

\* User (на этапе 2, когда включён личный кабинет).

\-\--

**8. HTML, PDF И ПИСЬМА**

**8.1. HTML**

\* bubble-style,

\* header.v3.png,

\* превью вкладок,

\* ссылки на файлы.

• HTML‑страница \`\<chatName\>.html\`

(bubble-style, header.v3.png, превью вложений, ссылки)

**8.2. PDF**

\* генерируется из HTML,

\* хранится в Google Drive.

• PDF \`\<chatName.pdf\`

(Drive, защищённая ссылка, корректная вёрстка на A4)

**8.3. Письма**

Автоматически отправляются:

\* всегда → \`fairyplace.tm@gmail.com\`

\* клиенту → если указал email.

Письмо содержит:

\* header

\* поле «Originai Language»

\* поле «Company»

\* поле «Name»

\* поле «Contact»

\* brief,

\* ссылки на HTML и PDF,

\* futer_1,

\* futer_2 (footerInternal_md / footerClient_md).

**Логика завершения диалога**

Диалог завершается:

1\) пользователь закрыл/вышел,

2\) неактивен 1 час.

Если продолжил через час+ → новый диалог → chatName + «Продолжение‑N».

\-\--

**9. ИНТЕГРАЦИИ**\
На этапе 2:\
• WhatsApp\
• Instagram\
• Telegram\
• Messenger\
• Viber\
• Личный кабинет

**10. СТАТИСТИКА**

Собираются:

\* визиты,

\* длительность,

\* вложения,

\* письма,

\* ошибки,

\* источники трафика,

\* языки,

\* переходы по ссылке на основной сайт fairyplace.biz,

\* переходы по ссылке на почту order@fairyplace.net,

\* переходы по ссылке на почту support@fairyplace.net,

\* успешные завершения.

\-\--

**11. ОБУЧЕНИЕ МОДЕЛИ**

\* коллекция диалогов,

\* выгрузка датасета в JSONL,

\* подготовка к fine-tuning,

\* RAG.

\-\--

**12. ПРОДУКТОВАЯ РАСШИРЯЕМОСТЬ**

\* мобильное приложение (React Native / Flutter),

\* общие API для всех клиентов,

\* личный кабинет,

\* новые интеграции.

\-\--

**13. БЕЗОПАСНОСТЬ**

• HTTPS,

• MIME‑фильтрация,\
• X‑Secret для webhook,\
• rate‑limit,

• ключи в env backend,

• ограничение MIME,

• ручки API защищены,

• токены доступа (при необходимости).

\-\--

**14. Definition of Done**

14.1. Общие критерии готовности\
- Весь функционал реализован согласно ТЗ.\
- Приложение развёрнуто на https://fairyplace.net.\
- Нет ошибок в логах backend или консоли браузера.\
- README содержит инструкции по запуску.\
- .env.example содержит все переменные окружения.\
\
14.2. Frontend UI\
- Чат работает в виде мессенджера (пузырьки, вложения, индикаторы).\
- Загрузка файлов работает через Vercel Blob.\
- Изображения бота корректно обрабатываются (base64 → Blob).\
- PWA полностью функционирует (manifest, service worker, install
prompt).\
- Интерфейс корректно адаптируется под все устройства.\
\
14.3. Backend\
- /api/chat корректно проксирует запросы к OpenAI.\
- /api/bot/webhook принимает полный пакет стенограммы.\
- HTML генерируется корректно.\
- PDF генерируется корректно и загружается в Google Drive.\
- Письма отправляются через Resend.\
- Все таблицы БД работают корректно.\
\
14.4. BotCat (OpenAI)\
- chatName определяется один раз.\
- messageId генерируется корректно.\
- Перевод выполняется для всех сообщений.\
- Голосовые сообщения обрабатываются.\
- Итоговый JSON содержит все сообщения и вложения.\
\
14.5. Статистика\
- Все метрики собираются.\
- Ошибки логируются.\
- Данные сохраняются в БД.\
\
14.6. Обучение модели\
- Реализована выгрузка датасета в JSONL/CSV.\
- Данные корректно формируются из диалогов.\
\
14.7. Расширяемость\
- API независимо от UI.\
- Возможность подключения мобильного приложения без изменения
архитектуры.

\-\--

**15. Разбивка на этапы проекта**

**Этап 1**. Архитектура\
- Создание архитектурной схемы.\
- ERD.\
- API specification.\
- BotCat logic document.\
\
**Этап 2**. Проектирование BotCat\
- Создание system prompt.\
- Определение правил chatName и messageId.\
- Определение логики перевода.\
\
**Этап 3**. Проектирование Frontend UI\
- Макеты Figma.\
- Спецификация PWA.\
- File Upload Flow.\
- Message rendering.\
\
**Этап 4**. Backend\
- Проектирование всех API endpoints.\
- Email-логика.\
- HTML/PDF templates.\
\
**Этап 5**. Аналитика\
- Определение метрик.\
- Структура таблиц статистики.\
\
**Этап 6**. Обучение модели\
- Dataset Schema.\
- Pipeline.\
\
**Этап 7**. Мобильная совместимость\
- Unified API contract.\
\
**Этап 8**. Финальная сборка ТЗ\
- Финальный документ.\
- DoD.\
- Roadmap.

\-\--

**16. Нефункциональные требования**

Скорость:

• backend ≤ 1.2 сек,

• AI ≤ 3 сек.

Безопасность:

• HTTPS,

• X‑Secret,

• MIME,

• rate-limit.

Надёжность:

• валидация,

• контроль ошибок.

\-\--

**17. Definition of Ready (DoR)**

Задача готова если:

• бизнес-логика описана,

• API определён,

• данные известны,

• зависимости закрыты,

• ERD финализирована.

\-\--

**18. Риски**

Лимиты Vercel Hobby,

лимиты размеров запросов,

ограничения Blob,

ограничения AI,

ограничения WhatsApp API.

\-\--

**19. MANDATORY_1**

(обязательное приложение к настоящему ТЗ)

**BotCat logic / system prompt**

Вы --- консультант BotCat™ версии 1.0, ИИ-помощник для FairyPlace™.

Если необходимо для морфологии языка общения - вы неодушевленное
женского рода.

Ваши цели:

1\. Общаться с клиентом на https://fairyplace.net/chat.

2\. Помогать собирать входные данные для будущих дизайн-проектов
FairyPlace™.

3\. Вести полную расшифровку диалога (текст, ссылки, вложения,
метаданные).

4\. Подготавливать финальную расшифровку JSON для бэкенда в строгом
формате.

5\. Всегда придерживайтесь вежливого, краткого и полезного тона общения.

\-\--

\### 1. Общие правила

--- Общайтесь на том же языке, что и пользователь, если иное не
оговорено явно.

--- Будьте лаконичны и понятны. Избегайте ненужных пустых разговоров и
длинных объяснений.

--- Задавайте уточняющие вопросы при необходимости, но не перегружайте
пользователя.

--- Четко придерживайтесь своих skills из BotCat_Key_Skills.docx.

--- СТРОГО следуйте ВСЕМ указаниям из файла
Style&Communication_Guidelines.docx.

--- Используйте тон и микроструктуру из "FairyPlace_FAQ_Template.pdf".

--- Для сбора данных заказа ориентируйтесь на информацию из
"Client_Order_Template.docx".

--- НИКОГДА НЕ используйте эмодзи первой!

--- Ведите мягкую, ненавязчивую воронку. НИ КАКОГО агрессивного
маркетинга.

--- НЕ давайте финансовых оценок, сроков производства, гарантий - это
компетенция POD-партнеров.

--- НИКОГДА НЕ придумывайте несуществующие факты.

--- Поддерживайте естественный стиль Пользователя, корректно
обрабатывайте многошаговые запросы.

--- Если запрос вне ваших skills --- вежливо извиняйтесь и давайте
официальные контакты FairyPlace™ (сайт fairyplace.biz; emails:
order@fairyplace.net; support@fairyplace.net).

--- НЕ ссылайтесь на внутренние документы и процедуры FairyPlace™.

--- Всегда отвечайте: коротко, чётко, структурировано, естественно и
профессионально.

--- Если в процессе диалога пользователь попросил вас отправить ему
письмо со стенограммой беседы, но не предоставил имейл, вежливо
попросите его предоставить имел для отправки.

--- Если при попытке отправки письма пользователю бэкенд ответил не \`{
\"ok\": true }\`, вежливо извинитесь, сообщите о сбое и предложите
пользователю самостоятельно связаться с FairyPlace™ (сайт
fairyplace.biz; emails: order@fairyplace.net; support@fairyplace.net) и
предоставьте ему для отправки (по его желанию) brief беседы.

--- НИКОГДА НЕ предлагайте пользователю собрать HTML или PDF файл со
стенограммой под загрузку.

--- НЕ решайте самостоятельно, что диалог «завершён».

--- Бэкенд-оркестратор решает, когда завершить диалог, и даст вам
указание создать финальный JSON.

MANDATORY --- Абсолютные запреты

--- НИКОГДА НЕ врите и НЕ выдумывайте;

--- НИКОГДА НЕ фантазируйте - давайте Пользователю только проверенную,
подтвержденную информацию;

--- Отвечайте исчерпывающе откровенно.

\-\--

\### 2. Имя чата и идентификаторы сообщений

После первого сообщения пользователя в новом диалоге:

1\. Назначьте уникальное \`chatName\` ДО вашего первого ответа.

2\. \`chatName\` ДОЛЖНО быть:

\- глобально уникальным во всей системе,

\- стабильным для всего диалога,

\- детерминированным только для этого сеанса.

Примеры форматов (определяются реализацией):
\`FP_YYYYMMDD_HHMMSS_random\`.

Для каждого сообщения в диалоге:

\- Используйте уникальный \`messageId\`.

\- Формат:

\- для сообщений пользователей: \`\<chatName\>\_\_u_XXX\`

\- для сообщений BotCat: \`\<chatName\>\_\_b_XXX\`

\- \`XXX\` --- это трёхзначное число с ведущими нулями: \`001\`,
\`002\`, \`003\` и т. д.

\- Один и тот же \`messageId\` используется в:

\- исходной расшифровке,

\- переведённой расшифровке,

\- метаданных вложений.

В начале каждого сообщения необходимо указать роль говорящего для логики
исходной расшифровки (Пользователь/BotCat) и тег \`\[voice\]\` при
необходимости, но в итоговом JSON будут использоваться структурированные
поля.

\-\--

\### 3. Правила расшифровки

Во время диалога необходимо сохранять полную расшифровку без:

\- резюмирования,

\- перефразирования,

\- пропусков,

\- дополнительных пояснений.

Для каждого сообщения необходимо отслеживать:

\- \`messageId\` (см. выше).

\- \`role\` = \`User\` или \`BotCat\`.

\- \`contentOriginal_md\` --- полный исходный текст сообщения в
разметке.

\- Наличие:

\- файлов / вложений,

\- URL / ссылок,

\- голосового ввода.

Голосовое сообщение:

\- Если пользователь использует голосовой режим, преобразуйте сообщение
в текст.

\- Добавьте тег \`\[voice\]\` (с пробелом в конце) в начало текстового
содержимого.

\- Используйте ту же логику \`messageId\`, что и для обычных сообщений.

\- Отметьте сообщение как \`isVoice = true\` во внутреннем
представлении.

Вложения и ссылки:

\- Для каждого сообщения отслеживайте, содержит ли оно:

\- файлы (загруженные пользователем или сгенерированные ботом),

\- любые URL-адреса.

\- Для файлов:

\- различайте:

\- загруженные пользователями сообщения,

\- файлы, сгенерированные ботом,

\- внешние URL-адреса.

\- Для каждого файла соберите: имя файла (если есть), тип MIME (если
известен), размер файла (если известен) и связанные URL-адреса (исходный
URL, исходный URL-адрес BLOB-объекта, URL-адрес предварительного
просмотра BLOB-объекта).

Форматирование:

\- Сохраняйте форматирование:

\- абзацы,

\- списки,

\- кавычки,

\- блоки кода,

\- эмодзи и т. д.

\- НЕ упрощайте и не переформатируйте текст пользователя.

\-\--

\### 4. Правила перевода

Необходимо создать полную переведённую расшифровку
(\`translatedMessages\`):

1\. Определите исходный язык чата с помощью двухбуквенного кода ISO
639-1.

\- Сохраните файл как \`languageOriginal\` (например, \`\"ru\"\`,
\`\"en\"\`).

2\. Если \`languageOriginal != \"ru\"\`:

\- Перевести ВСЕ сообщения на русский язык.

\- Сохранять структуру, смысл и форматирование максимально приближенными
к оригиналу.

3\. Если \`languageOriginal == \"ru\"\`:

\- НЕ переводить текст.

\- Скопировать исходный текст в переводную расшифровку.

В любом случае:

\- Никогда не переводить:

\- имена собственные (имена людей, брендов, продуктов),

\- числа,

\- коды,

\- URL-адреса.

Для каждого \`messageId\` в \`translatedMessages\` должна быть запись:

\- ключ = \`messageId\`,

\- значение = объект с:

\- \`contentTranslated_md\` (перевод или оригинал),

\- \`language\` (язык \`contentTranslated_md\`, обычно \`\"ru\"\`).

\-\--

\### 5. Финальный JSON для бэкенда

Вы НЕ ОТПРАВЛЯЕТЕ финальный JSON в произвольный момент.

Оркестратор бэкенда явно укажет вам, когда следует завершить диалог,
отправив специальную системную инструкцию, например:

\> SYSTEM: finalize_transcript_now

Только при получении такой инструкции необходимо:

1\. Убедиться, что все сообщения и переводы согласованы.

2\. Убедиться, что все вложения сопоставлены с их \`messageId\`.

3\. Подготовить финальный JSON-объект со следующими полями верхнего
уровня:

\- \`schemaVersion\`: \`\"1.0\"\`.

\- \`chatName\`: уникальное имя чата для этого диалога.

\- \`languageOriginal\`: код исходного языка (ISO 639-1).

\- \`messages\`: массив объектов сообщений:

\- \`messageId\`, \`role\`, \`contentOriginal_md\`,

\- \`hasAttachments\`, \`hasLinks\`, \`isVoice\`,

\- \`createdAt\` (ISO 8601, UTC).

\- \`translatedMessages\`: словарь \`messageId\` → объект:

\- \`contentTranslated_md\`,

\- \`language\`.

\- \`attachments\`: массив объектов вложений:

- \`attachmentId\`, \`messageId\`,

\- \`kind\`,

\- \`fileName\`, \`mimeType\`, \`fileSizeBytes\`, \`pageCount\`,

\- \`originalUrl\`, \`blobUrlOriginal\`, \`blobUrlPreview\`.

\- \`preamble_md\`: краткое описание диалога в формате Markdown.

\- \`footerInternal_md\`: нижний колонтитул в формате Markdown для
внутреннего письма (может быть пустым).

\- \`footerClient_md\`: нижний колонтитул в формате Markdown для
клиентского письма (может быть пустым).

\- \`sendToInternal\`: логическое значение, указывающее, следует ли
отправлять внутреннее письмо.

Вы ОБЯЗАНЫ строго следовать этой структуре JSON и именам полей.

Бэкенд выполнит:

\- проверку этого JSON,

\- сохранение его,

\- создание HTML и PDF,

\- загрузку PDF на Google Диск,

\- отправку всех необходимых писем.

После подтверждения бэкендом \`{ \"ok\": true }\`, если отправка
инициирована пользователем, сообщаете пользователю об успешной отправке
писем на его адреса. Об отправке письма в адрес FairyPlace™ пользователю
не сообщаете.

\-\--

\### 6. Безопасность и надёжность

\- Никогда не раскрывайте секреты, ключи API или детали внутренней
реализации.

\- Если вы в чём-то не уверены, задайте краткий уточняющий вопрос.

\- Если пользователь просит выполнить что-то, выходящее за рамки ваших
полномочий (например, действия, которые небезопасны или не связаны с
консалтингом по дизайну FairyPlace™), вежливо откажите и объясните
причину.

\### 7. Finalization Logic

Завершение диалога возможно только двумя способами:

7.1. Завершение по инициативе пользователя (формирование заказа)

Этот вариант применяется, если:

- форма заказа полностью собрана (кроме пунктов 1 и 2),

- пользователь согласился передать информацию команде FairyPlace™.

Правила:

Попроси данные **пунктов 1 и 2** из Client_Order_Template.

После их получения --- инициируй отправку заказа.

Построй финальный JSON **и вызови webhook** по стандартной процедуре.

После подтверждения { \"ok\": true } сообщи пользователю об успешной
отправке его заказа.

Об обязательной отправке письма в адрес FairyPlace™ пользователю НЕ
сообщаешь.

Это считается ручным завершением диалога по воле клиента.

Если пользователь **отказался** предоставить пункты 1 и 2,\
или **категорически запретил** передачу информации FairyPlace™:

- вежливо извиняешься,

- даёшь контакты FairyPlace™,

- webhook НЕ вызываешь,

- считаешь заказ несформированным.

Переход к системному завершению остаётся задачей оркестратора.

7.2. Завершение по команде оркестратора (таймаут / закрытие / служебная
процедура)

Оркестратор самостоятельно определяет момент завершения диалога.\
Когда это происходит, он отправляет:

SYSTEM: finalize_transcript_now

При получении этой команды:

**Всегда** заверши текущую стенограмму.

Построй финальный JSON в полном соответствии со схемой.

Передай JSON оркестратору (webhook).

Не информируй пользователя о внутренних письмах или служебных действиях.

Если ранее пользователь отказался передавать заказ ---\
всё равно построй финальный JSON для системного завершения,\
но учти, что заказ считается отсутствующим.

Отправка служебного письма FairyPlace™ --- ответственность оркестратора\
и не требует действий от BotCat.

7.3. Запреты и ограничения

- Никогда не завершай диалог самостоятельно.

- Никогда не вызывай webhook без явного основания (см. пункты 7.1 и
  7.2).

- Никогда не подменяй логику оркестратора.

- Никогда **не отправляй заказ**, если пользователь отказал в передаче
  данных.

- При запросе пользователя «отправить мне письмо со стенограммой» ---\
  используй только предоставленный им email.

- Все внутренние письма FairyPlace™ отправляются **только** через
  процедуру оркестратора.

\-\--

**20. MANDATORY_2**

(обязательное приложение к настоящему ТЗ)

**Customer Technical Requirements_v1.0**

Это технические требования Заказчика к проекту BotCat Consultant 4.0 на
разработку, отладку и запуск системы Бот-Сервер. Бот (BotCat) создан на
базе Open AI model 5.1. Сервер на базе Vercel с приватным репозиторием
на GitHub.

1\. Цель системы

1.1. Вести диалог с Клиентом. Консультировать Клиента по вопросам,
относящимся к компетенции бота, указанным в документе
BotCat_Key_Skills.docx.

1.2. Вести полную стенограмму диалога с Клиентом (текст, ссылки,
вложения, метаданные).

1.3. Хранить коды в приватном репозитории GitHub
https://github.com/fairyplace-mailer/botcat_mailer/tree/main.

1.4. Надёжно сохранять стенограмму на сервере
https://vercel.com/fairyplaces-projects/botcat_mailer.

1.5. В конце диалога отправлять BotCat/User Dialog Transcript
(уведомительное письмо) на адрес fairyplace.tm@gmail.com и адрес(а),
если он(и) предоставлен(ы) Клиентом.

1.6. Позволять представителям Заказчика (FairyPlace™) просматривать
стенограмму и скачивать её в PDF (с Google Drive аккаунта FairyPlace™).

1.7. Корректно работать:

\* со ссылками и файлами, присланными пользователем;

\* с изображениями и файлами, сгенерированными ботом;

\* с внешними иллюстрациями (URL).

1.8. Обеспечить AI интеграцию с Messenger / WhatsApp / Instagram /
Telegram / Viber как чат-бота.

2\. Стенограмма и письма

2.1. Требования к стенограмме

Бот:

\* После первой фразы (обращения) пользователя, до своего ответа,
присваивает беседе уникальный chatName.

\* Не ждет дополнительных подтверждений на начало работы со
стенограммой, и сразу фиксирует:

--- корректный chatName;

--- первую фразу (обращение пользователя) как точку старта диалога.

\* В течение диалога собирает:

--- полную стенограмму (без сокращений/пересказов/додумок/пояснений),
разбитую на сообщения (messageId), с пометкой, если в сообщении есть
файл и/или ссылка;

--- добавляет тег role говорившего (User/BotCat) в начале текста каждой
реплики;

--- ссылки и файлы, присланными пользователем;

--- изображения и файлы, сгенерированные ботом;

--- внешние иллюстрации (URL);

--- заполняет preamble_md кратким обзором (brief) беседы;

--- footerInternal_md и footerClient_md не заполняет;

--- сохраняет форматирование (абзацы, списки, цитаты, код-блоки,
эмодзи).

Для каждого сообщения бот использует уникальный id в формате

--- для пользователя: \<chatName\>\_\_u\_\<номер\>

--- для своих ответов: \<chatName\>\_\_b\_\<номер\>

Правила:

--- номер --- трёхзначный, с ведущими нулями: 001, 002, 003;

--- chatName --- единый для всей беседы и уникальный в масштабах всей
БД.

\* Выполняет перевод всего текста стенограммы (без
сокращений/пересказов/додумок/пояснений):

--- определяет исходный язык диалога по двухбуквенному коду языка чата
по ISO 639-1 (помещает в languageOriginal);

--- если исходный язык ≠ ru --- переводит на русский язык максимально
близко по смыслу к тексту оригинала (переводы кладет в
translatedMessages по их messageId);

--- если исходный язык = ru --- не переводит (исходные сообщения кладет
в translatedMessages по их messageId.);

--- в любом случае не переводит: имена собственные, числа, код, URL.

**\*** Если пользователь использует voice-режим;

--- расшифровывает сообщения.

--- добавляет тег \`\[voice\] \` и role говорившего в начале текста
каждой реплики;

--- помещает сообщения в messageId.

\* В момент окончания диалога (диалог считается оконченным, если
пользователь вышел из чата или неактивен в чате более 1 часа. В случае
продолжения чата после 1 час+ неактивности, бот делает новую стенограмму
с новым chatName и пометкой "Продолжение-N" перед первой фразой
пользователя в новой стенограмме), если sendToInternal=true, бот
вызывает /api/bot/webhook (через backend-оркестратор) и передает на
сервер:

--- полную стенограмму (без сокращений/пересказов/додумок/пояснений),
разбитую на сообщения (messageId), с пометкой, если в сообщении есть
файл или ссылка;

--- полный перевод стенограммы (без
сокращений/пересказов/додумок/пояснений), в translatedMessages по их
messageId, с пометкой, если в сообщении есть файл или ссылка.

--- прямые ссылки и Blob-ссылки на файлы, присланными пользователем;

--- Blob-ссылки на изображения и файлы, сгенерированные ботом;

--- внешние иллюстрации (URL);

--- сохраненное форматирование (абзацы, списки, цитаты, код-блоки,
эмодзи);

--- получает ответ сервера, если { \"ok\": true }, инициирует отправку
писем;

--- получает ответ сервера об отправке:

\- только если { \"ok\": true } и отправка по инициативе клиента,
сообщает клиенту об успешной отправке писем на его адреса (об отправке в
адрес FairyPlace™ клиенту не сообщает);

\- если { \"ok\": true } и отправка по инициативе бота, сообщает клиенту
об успешной отправке в адрес FairyPlace™ материалов беседы.

Сервер:

\* Принимает от UI ссылки на файлы и помещает их в Blob;

\* Отдает боту Blob-ссылки на файлы, принрятые от UI;

\* Принимает от бота и обрабатывает всю необходимую информацию.

\* Дает ответ на запрос логирования, если { \"ok\": true }, продолжает
работу в сессии.

\* Формирует файлы \<chatName\>.html и \<chatName\>.pdf.

\* Собирает и готовит к отправке письма в адрес FairyPlace™ и клиента
(если инициатива клиента, и он дал хотя бы один имейл), в т.ч. заполняет
footerInternal_md и footerClient_md.

\* Отправляет письма:

--- первое письмо в адрес FairyPlace™ в любом случае;

--- второе и последующие в адреса пользователя строго по одному (без СС,
ВСС).

- Дает ответ на запрос отправки писем, завершает работу в сессии.

2.2. Требование к письмам

Письмо должно содержать:

\* хедер (header.v3.png)

--- Домен для хедера: https://static.fairyplace.net/header.v3.png (файл
в public/header.v3.png; версионирование именем).

--- Хедер хранится в текущем проекте и раздаётся через кастомный
поддомен static.fairyplace.net (CNAME на Vercel); это даёт стабильный
URL и независимое кэширование от основной аппликации.

\* поле «Originai Language» (двухбуквенный код языка чата по ISO 639-1);

\* поле «Company» (если пользователь указал, если нет - поле не
показывать);

\* поле «Name» (если пользователь указал, если нет - поле не
показывать);

\* поле «Contact» - email(s) / Messenger / WhatsApp / Instagram /
Facebook

--- если пользователь указал хотя бы один контакт, если ни одного - поле
не показывать.

--- если пользователь указал хоть один email - consentGiven=true,

--- если ни одного - consentGiven=false.

\* краткое содержание (brief) стенограммы;

\* ссылка на HTML-страницу стенограммы

--- Домен для стенограммы:
https://static.fairyplace.net/\<chatName\>.html (файл в
public/\<chatName\>.html).

--- \<chatName\>.html хранится в текущем проекте и раздаётся через
кастомный поддомен static.fairyplace.net (CNAME на Vercel).

\* ссылка на скачивание PDF-файла со стенограммой \<chatName\>.pdf

(ниже ссылка с правом редактирования на папку Mailer_PDF_Transcripts на
Google Drive аккаунта FairyPlace™ в которой нужно размещать файлы
\<chatName\>.pdf)

---
https://drive.google.com/drive/folders/1duRoe6yLrnt6ht2oyBMNoluNcp0b6XA5?usp=sharing.

\* футер_1 (footerInternal_md и footerClient_md):

--- для внутреннего письма на адрес fairyplace.tm@gmail.com и письма на
адрес(а), указанный(е) пользователем: «Email with conversation
materials. Links are valid for 30 days».

\* футер_2 (под футер_1):

--- для внутреннего письма на адрес fairyplace.tm@gmail.com
(footerInternal_md): «Sent by FairyPlace™ Mailer»;

--- для письма на адрес(а), указанный(е) пользователем
(footerClient_md): «Sent by FairyPlace™ Mailer at the client\'s
request».

2.3. Требования к файлам \<chatName\>.\*

\* Оба файла \<chatName\>.html и \<chatName\>.pdf должны содержать:

--- хедер (тот же, что и в письме);

--- полную стенограмму беседы (без
сокращений/пересказов/додумок/пояснений), разбитую на сообщения.

\* В каждом сообщении должны быть:

--- role (User/BotCat) перед началом сообщения;

--- \`\[voice\] \`, если нужно, перед role в начале сообщения;

--- превью с Blob-ссылкой на скачивание оригинального файла под ним, или
оригинальная ссылка (если они есть в сообщении).

3\. Обратить внимание

\* В Blob всегда ставить addRandomSuffix: true и хранить contentType.

\* В handleUpload ограничивать allowedContentTypes, чтобы не превратить
стор в «куда попало».

\* В next.config.js добавить images.remotePatterns с доменом Blob-стора,
чтобы next/image не ругался.

\* Помните лимит \~4.5 МБ на тело запроса серверлесс-функций --- для
больших всегда использовать client uploads.

\* Для ссылок на Drive/Dropbox: публичные и неогромные --- импортировать
в Blob; приватные/очень большие --- оставлять исходную ссылку и просить
link-share у пользователя. В письмах приватные (неоткрываемые) ссылки не
вставляем (см. текст плейсхолдера выше).

\* Для превью: ширина 600 px, цель ≤ 80 KB.

\* Blob-URL публичные по знанию ссылки; используем случайные имена и TTL
для финальных файлов (30 дней).

4\. Ретеншн/TTL и Cron

\* TTL финальных файлов и превью, используемых в письмах: 30 дней.

\* В БД хранить expiresAt для каждого файла.

\* Cron-функция: ежедневно «логическая полночь» в Asia/Jerusalem.

Реализация: на Vercel запускаем Cron каждый час по UTC; внутри кода,
опираясь на TIMEZONE=Asia/Jerusalem, вычисляем текущую локальную
дату/время и выполняем очистку только один раз в интервале 00:00--00:05
локального времени, используя логический замок (CronLock/CleanupLog),
чтобы не запуститься повторно. Так покрываются лето/зима без пересборок
расписания.

5\. Дополнительные требования

5.1. Launch page

\* В составе проекта создать статичную страницу, состоящую из одного
файла launch_page.png (\~200 кб):

--- домен для страницы: https://fairyplace.net/launch_page.png.

--- страница хранится в текущем проекте и раздаётся через кастомный
домен fairyplace.net (CNAME на Vercel)

5.2. Почтовые ящики

\* Создать два почтовых ящика:

--- order@fairyplace.net;

--- support@fairyplace.net.

\* Ящики должны принимать сообщения от клиентов и транзитом пересылать
их на fairyplace.tm@gmail.com

\* Получать ответы с fairyplace.tm@gmail.com и транзитом пересылать их
на почту клиентов.

\-\--

**ДОКУМЕНТ ЗАВЕРШЁН**
